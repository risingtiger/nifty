(() => {
  // server/static_dev/sw.js
  var cache_name = "cacheV__3013__";
  var SHOULD_CACHE = cache_name.includes("__0__") ? false : true;
  self.addEventListener("controllerchange", (_e) => {
    console.log("controllerchange");
  });
  self.addEventListener("install", (e) => {
    console.log("install");
    let promise = new Promise(async (res, _rej) => {
      self.skipWaiting();
      res(1);
    });
    e.waitUntil(promise);
  });
  self.addEventListener("activate", (e) => {
    console.log("activate");
    let promise = new Promise(async (res, _rej) => {
      if (SHOULD_CACHE) {
        let x = await caches.keys();
        x.forEach(async (c) => {
          if (c !== cache_name)
            await caches.delete(c);
        });
      }
      self.clients.claim();
      res(1);
    });
    e.waitUntil(promise);
  });
  self.addEventListener("fetch", (e) => {
    let promise = new Promise(async (res, _rej) => {
      if (SHOULD_CACHE) {
        const cache = await caches.open(cache_name);
        const match_r = await cache.match(e.request);
        if (match_r) {
          res(match_r);
        } else {
          if (should_url_be_cached(e.request)) {
            const r = await fetch(e.request);
            if (r.ok)
              cache.put(e.request, r.clone());
            res(r);
          } else {
            const r = await fetch(e.request);
            res(r);
          }
        }
      } else {
        const r = await fetch(e.request);
        res(r);
      }
    });
    e.respondWith(promise);
  });
  self.addEventListener("message", async (e) => {
    if (SHOULD_CACHE && e.data.command === "load_core") {
      caches.open(cache_name).then(function(cache) {
        cache.add("/");
        cache.add("/index.html");
        cache.add("/app_v" + cache_name.split("__")[1] + ".webmanifest");
      });
    }
  });
  self.addEventListener("push", (e) => {
    if (self.Notification.permission == "denied") {
      return;
    }
    if (self.Notification.permission == "default") {
    }
    try {
      const msg = e.data.json().data;
      const options = {
        body: msg.body
      };
      e.waitUntil(self.registration.showNotification(msg.title, options));
    } catch (err) {
      throw new Error("Error in SW: " + err);
    }
  });
  self.addEventListener("notificationclick", (event) => {
    event.waitUntil();
  });
  function should_url_be_cached(request) {
    if (request.url.includes(".webmanifest")) {
      return true;
    } else if (request.url.includes("/lazy/")) {
      return true;
    } else if (request.url.includes("/media/")) {
      return true;
    } else {
      return false;
    }
  }
})();
